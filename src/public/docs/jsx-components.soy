{namespace docsJSXComponents}

/**
 * This template will be rendered by SoyWeb when the user loads static.soy.
 * It deliberately includes dummy data so the designer can get a feel for how
 * the task list will appear with real data rather with minimal copy and paste.
 */
{template .soyweb}
{call docs.layout}
	{param content kind="html"}
		<h1>JSX Components</h1>

		<p>
			For a practical tutorial on how to build components using JSX templates,
			make sure to follow
			the <a href="/docs/modal.html">Modal tutorial</a> section.
		</p>

		<p>
			This guide will explain some details about the integration
			between <strong>Metal.js</strong> components
			and <a href="https://facebook.github.io/jsx/">soy templates</a>.
		</p>

		<p>
			Note that <strong>Metal.js</strong> is template agnostic, so it's not
			necessary to use JSX at all. That said, we already provide a very good
			integration between metal components and JSX, so if you like using it
			you should give it a try.
		</p>

		<h2>JSXComponent</h2>

		<p>
			The only thing you need to do to use JSX in
			your <strong>Metal.js</strong> component is to
			extend from <strong>JSXComponent</strong>, like this:
		</p>

		<textarea class="code" data-mode="javascript">
{literal}import JSXComponent from 'metal-jsx';

class MyComponent extends JSXComponent {
}

export default MyComponent;{/literal}
		</textarea>

		<h2><code>render</code> function</h2>

		<p>
			Now that we've extended from <strong>JSXComponent</strong> we can use jsx
			in the <code>render</code> method to specify what our component should
			render.
		</p>

		<textarea class="code" data-mode="javascript">
{literal}import JSXComponent from 'metal-jsx';

class MyComponent extends JSXComponent {
	render() {
		return &lt;div class={this.config.cssClass}&gt;
			Hello {this.name}
		&lt;/div&gt;;
	}
}

MyComponent.STATE = {
	name: {
		validator: core.isString,
		value: 'World'
	}
};

export default MyComponent;{/literal}
		</textarea>

		<p>
			Note that your component can have two different types of
			data: <a href="/docs/state.html">state</a> and <a href="/docs/state.html#config">config</a>.
			The main difference is that config is accessed
			via <code>this.config</code> and will be the original data received from
			parent components or the constructor. State is accessed directly
			from <code>this</code> though, like <code>this.name</code> in the previous
			example, and can be configured to use validators, setters, initial values
			and other features. Check out the guide
			about <a href="/docs/state.html">state</a> to learn more about this.
		</p>

		<h2>JSX compilation</h2>

		<p>
			For the integration
			between <strong>Metal.js</strong> and <strong>JSX</strong> to work, the
			JSX code needs to be compiled via a babel plugin
			called <a href="http://npmjs.com/package/babel-plugin-incremental-dom">babel-plugin-incremental-dom</a>.
			Using it directly means you'd need to configure it manually though, so we
			also provide
			a <a href="http://npmjs.com/package/babel-preset-metal-jsx">babel preset</a> that
			you can use instead.
		</p>

		<h2>Functional components</h2>

		<p>
			Sometimes you'll create very simple components, that have no other behavior
			besides rendering their own contents. In this case you can drop using
			classes, and instead create simple functions that just render the contents
			instead.
		</p>

		<p>
			For example, let's create a simple <strong>Button</strong> component as
			a function:
		</p>

		<textarea class="code" data-mode="javascript">
{literal}/**
 * Functional components receive the configuration
 * object as the first param.
 */
function Button({ cssClass, label }) {
  return &lt;button type="button" class={cssClass}&gt;{label}&lt;/button&gt;;
}{/literal}
		</textarea>

		<p>
			You can then use it from parent components in the same way that you'd use
			a component class, for example:
		</p>

		<textarea class="code" data-mode="javascript">
{literal}&lt;Button cssClass="btn btn-primary" label="OK" /&gt;{/literal}
		</textarea>
	{/param}
{/call}
{/template}
